\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[brazil]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[colorinlistoftodos]{todonotes}

\title{Relatório Exercício Programa III - Batalha de Robôs}
\author{
Fellipe Souto Sampaio \footnote{Número USP: 7990422 e-mail: fellipe.sampaio@usp.com}\\
Gervásio Protásio dos Santos Neto \footnote{Número USP: 7990996 e-mail: gervasio.neto@usp.br}\\
Vinícius Jorge Vendramini \footnote{Número USP: 7991103 e-mail: vinicius.vendramini@usp.br}
}

\begin{document}
\maketitle

\begin{center}
MAC 0242 Laboratório de Programa\c{c}ão II \\
Prof. Marco Dimas Gubitoso \\
             
\end{center}

\begin{center}
Instituto de Matemática e Estatística - IME USP \\
 Rua do Matão 1010 \\
 05311-970\, Cidade Universitária, São Paulo - SP \\
\end{center}

\newpage

\section{Introdução}

Esse relatório se destina a explicar a implementação do Terceiro Exercicío-Programa da disciplina de Laborátorio de Programação II.\\
Nesta etapa do projeto houve um refinamento das etapas anteriores através da implementação de uma interface gráfica e do processamento das chamadas ao sistema.\\
No tocante gráfico utilizou-se das bibliotecas padrões do java Swing e Jframe como arcabouço para criação de uma arena virtual e para representação das demais entidades que estão presente no jogo.\\
Na maquina virtual houve uma otimização do seu funcionamento através de certas mudanças feitas no Parser\\
Por fim diversas chamadas ao sistema foram implementadas e estão operantes e visualizaveis através da interface gráfica.

\newpage
\section{Interface Gráfica}
\subsection{Aspectos Estruturais}
falar sobre como é dividido
\subsection{Aspectos Funcionais}
Explicar sucintamente como funciona
elencar a estrutura de dependência das classes e falar um pouco sobre os principais métodos

\section{Robôs}
\subsection{Battlerobot}
\subsection{Maquina Virtual}
\subsection{Syscall}
\subsection{Parser}

Uma das principais mudanças em relação à fase anterior reside na classe Parser. Anteriormente cada time possuía um código fonte próprio, restringindo a diversidade de funcionamento dos robôs em campo. Nesta fase Parser foi alterado de forma que agora seja possível que cada robo tenha um source code próprio, aumentando substancialmente a gama de possibilidades do jogo. Para isso o sistema procura um arquivo chamado \textit{sourceCode-x}, onde x varia de 0 até n-1 quantidade de robôs em jogo. Caso o código fonte não seja encontrado o jogo carrega no robô o código \textit{defaultSource}, que possui um conjunto de instruções básicas definidas pelo usuário, essa decisão é tomada com intuito de possibilitar o funcionamento do jogo mesmo que nenhum código tenha sido escrito para um robô em específico.\\
Por fim utilizou-se algumas técnicas do Java para navegação através de diretórios para centralizar os códigos fonte utilizados ao longo do jogo. O diretório padrão de leitura dos códigos é \textit{sourceCodes}, subdiretório da pasta principal do Battlefield.




\section{Battlefield}
\subsection{Funcionamento do jogo}
O laço principal de funcionamento do jogo acontece na função \textit{runTheGame}. Esta função pode ser dividida em três etapas:

\begin{itemize}
\item[•]{Execução de um ciclo de instruções da máquina.}
\item[•]{Processamento das requisições ao sistema feitas pelos robôs.}
\item[•]{Verificação se a condição de funcionamento do laço ainda é verdadeira.}
\end{itemize}

No primeiro item a arena navega linearmente através do vetor de robôs deixando com que cada um execute um número $\psi$ fixo de instruções de máquina. A arena espera que o robô faça uma requisição ao sistema durante essas ins-truções, todavia se o robô executar $\psi$ instruções sem nenhuma chamada ao sistema a arena causa uma interrupção no processamento da maquina virtual e força que esta faça uma chamada vazia, para assim permitir que outros robôs executem suas instruções evitando que o sistema fique preso em um looping infinito. As chamadas ao sistema são feitas através do método \textit{systemCall}, no qual cada robô insere na lista requesList um pedido, modelado através do objeto \textit{SystemRequest}. 

Na segunda etapa o sistema, que ja terminou de processar todas os robos, começa a processar as requisições que foram feitas. Embora o vetor de robôs sempre seja percorrido linearmente o sistema aleatoriza o vetor de requisições, evitado com que um robô tenha vantagem sobre outro. Após a aleatorização da lista um iterador percorre-a executando cada chamada através do método \textit{executeCall}. A arena é atualizadas graficamente ao final desta etapa.

E no fim o sistema verifica se a condição que o mantem dentro do laço do jogo ainda é verdadeira. Ao navegar linearmente através do vetor de robôs o sistema conta quantos estão inativos\footnote{entende-se \textit{inativo} como um robô que chegou a o fim da sua execução (comando END) ou que foi destruído durante a batalha.}, caso o número de robôs inativos seja o mesmo de robôs em jogo o laço é quebrado e a execução do jogo termina. 

\subsection{Processamento das syscalls}
Cada chamada ao sistema é um solicitação muito bem definida para que não exis-ta ambiguidade. Em cada uma dessas chamadas uma ação diferente acontece, como é explicitado a seguir:

\begin{itemize}
\item[•]{WLK - Anda pela arena utilizando uma das seis direções possíveis (leste,oeste, nordeste,sudeste,sudoeste e noroeste).}
\item[•]{FIRE - Atira na direção solicitada.}
\item[•]{BOMB - Planta uma bomba na direção solicitada e a cada nova rodada o timer é decrementado.}
\item[•]{LOOK - Olha para uma direção solicitada e pergunta o que existe ai, podendo ser cristal, bomba, inimigo, amigo ou nada.}
\item[•]{ASK - Faz perguntas ao sistema sobre a quantidade de energia que um robô tem, sua quantidade de cristais, a distância em linha reta até a base inimiga e o mesmo calculo de distância até a sua base.}
\end{itemize}
\subsection{Atualização da arena}
Explicar como funciona a atualização da arena

\section{Compilação e funcionamento}
Para compilar utilize comando ant via terminal; será criado um arquivo executável \textit{BF.jar} na pasta \textit{dist/}. Para executar o programa é necessário escrever os códigos fonte para os robôs e guardar na pasta \textit{sourceCodes} com o nome apropriado (sourceCode-0, sourceCode-1, etc); caso contrário, será usado o \textit{defaultSource} como o arquivo padrão para os robôs.

\subsection{Tarefas futuras}
\begin{itemize}
\item{Implementação das ultimas instruções do sistema.}
\item{Melhora em certas animações.}
\item{Limpeza do código quanto a disposição das classes.}
\item{Redução de redundâncias e pleonasmos no código.}
\item{Separação dos arquivos quanto ao seu tipo através de pastas.}
\item{Compactação em um arquivo jar.}
\end{itemize}

Mais alguma?
->Melhoridas na parte gráfica
	-->Background
	-->Tamanho fixo da janela
	-->Contorno dos hexagonos

\end{document}
